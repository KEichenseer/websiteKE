xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
legend("topleft", legend = c("observations","true relationship", "lm() regression"
), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), pt.lwd = c(0,NA,NA), col = c(NA,rgb(0.5,0.5,0.5,1),"black"), lty = c(NA,1,2,2), cex = .65)
legend("bottomright", legend = c("JAGS estimates",
"JAGS regression"), pt.bg  = c(rgb(0.9,0.33,0,0.5), NA), pch = c(24,NA), lwd = c(NA,2),  pt.cex = c(1,NA,NA,NA), pt.lwd = c(0,NA), col = c(NA,rgb(0.9,0.33,0,1)), lty = c(NA,2), cex = .65)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
regmat <- matrix(NA,nrow = 1500, ncol = length(x_seq))
for(i in 1:1500) {
regmat[i,] <- lm_jags$BUGSoutput$sims.list$alpha[i] + lm_jags$BUGSoutput$sims.list$beta[i]*x_seq
}
reg_025 <- apply(regmat, 2, function(x) quantile(x, probs = 0.025))
reg_975 <- apply(regmat, 2, function(x) quantile(x, probs = 0.975))
ciPoly(x_seq, reg_975,reg_025, col = rgb(0.9,.33,0,0.25))
points(range(x_obs), lm_jags$BUGSoutput$mean$alpha + range(x_obs)*lm_jags$BUGSoutput$mean$beta, type = "l", col = rgb(0.9,.33,0,1),lwd=2)
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l")
points(lm_jags$BUGSoutput$mean$x_est,lm_jags$BUGSoutput$mean$y_est,pch=24, col = NA, bg = rgb(0.9,0.33,0,0.5))
sapply(1:n,function(a) points(points(c(lm_jags$BUGSoutput$mean$x_est[a],x_obs[a]),c(lm_jags$BUGSoutput$mean$y_est[a],y_obs[a]), type = "l", lty = 3, col = rgb(0.9,0.33,0,0.5))
))
set.seed(1) # change the seed for a different sequence of random numbers
n <- 30 # number of total data points
x <- runif(n,-2,2) # generate the true x
y <- 2 + 0.75 * x # generate the true y
# define the standard deviations of the normal uncertainties with which x and y where observed
x_sd <- runif(n,0.1,0.25)
y_sd <- runif(n,0.1,1)
# generate observations from x and y, given these uncertainties
x_obs <- rnorm(n,x,x_sd)
y_obs <- rnorm(n,y,y_sd)
# function to show uncertainty shadings
ciPoly <- function(x,en,ep,color=rgb(0,0,0,0.2)) {
polygon( c(x[1], x, x[length(x)], x[length(x)], rev(x), x[1]),
c((ep)[1],ep, (ep)[length(ep)], (en)[length(en)], rev(en), (en)[1]),
border = NA, col = color)}
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l", col = rgb(0,0,0,1))
legend("topleft", legend = c("observations","true relationship", "linear regression"), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), bty = "n", pt.lwd = c(0,NA,NA), col = c(NA,rgb(.5,.5,.5,1),rgb(0,0,0,1)), lty = c(NA,1,2), cex = .65)
errors_in_variables_regression_jags <- function() {
## Likelihood
for (i in 1:n){ #
x_est[i] ~ dnorm(x_obs[i], 1/(x_sd[i]*x_sd[i])) # precision = 1/sigma^2
y_obs[i] ~ dnorm(y_est[i], 1/(y_sd[i]*y_sd[i])) # precision = 1/sigma^2
y_est[i] ~ dnorm(mu[i], tau) # JAGS uses precision `tau` instead of sigma
mu[i] <- alpha + beta * x_est[i]
}
## Priors
tau ~ dgamma(1, 1)  # gamma prior for precision
sigma <- 1/sqrt(tau) # calculate standard deviation
alpha ~ dnorm(0, 1/(100*100))
beta ~ dnorm(0, 1/(100*100))
}
library(R2jags)
regression_data <- list("x_obs", "y_obs", "x_sd", "y_sd","n")
lm_jags  <- jags(data = regression_data,
parameters.to.save = c("alpha",
"beta",
"sigma",
"y_est",
"x_est"
),
n.iter = 3000,
n.thin = 1,
n.chains =  3, # Other values set at default (for simplicity)
model.file = errors_in_variables_regression_jags)
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
legend("topleft", legend = c("observations","true relationship", "lm() regression"
), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), pt.lwd = c(0,NA,NA), col = c(NA,rgb(0.5,0.5,0.5,1),"black"), lty = c(NA,1,2,2), cex = .65)
legend("bottomright", legend = c("JAGS estimates",
"JAGS regression"), pt.bg  = c(rgb(0.9,0.33,0,0.5), NA), pch = c(24,NA), lwd = c(NA,2),  pt.cex = c(1,NA,NA,NA), pt.lwd = c(0,NA), col = c(NA,rgb(0.9,0.33,0,1)), lty = c(NA,2), cex = .65)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
regmat <- matrix(NA,nrow = 1500, ncol = length(x_seq))
for(i in 1:1500) {
regmat[i,] <- lm_jags$BUGSoutput$sims.list$alpha[i] + lm_jags$BUGSoutput$sims.list$beta[i]*x_seq
}
reg_025 <- apply(regmat, 2, function(x) quantile(x, probs = 0.025))
reg_975 <- apply(regmat, 2, function(x) quantile(x, probs = 0.975))
ciPoly(x_seq, reg_975,reg_025, col = rgb(0.9,.33,0,0.25))
points(range(x_obs), lm_jags$BUGSoutput$mean$alpha + range(x_obs)*lm_jags$BUGSoutput$mean$beta, type = "l", col = rgb(0.9,.33,0,1),lwd=2)
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l")
points(lm_jags$BUGSoutput$mean$x_est,lm_jags$BUGSoutput$mean$y_est,pch=24, col = NA, bg = rgb(0.9,0.33,0,0.5))
sapply(1:n,function(a) points(points(c(lm_jags$BUGSoutput$mean$x_est[a],x_obs[a]),c(lm_jags$BUGSoutput$mean$y_est[a],y_obs[a]), type = "l", lty = 3, col = rgb(0.9,0.33,0,0.5))
))
set.seed(1) # change the seed for a different sequence of random numbers
n <- 30 # number of total data points
x <- runif(n,-2,2) # generate the true x
y <- 2 + 0.75 * x # generate the true y
# define the standard deviations of the normal uncertainties with which x and y where observed
x_sd <- runif(n,0,0.25)
y_sd <- runif(n,0.1,1)
# generate observations from x and y, given these uncertainties
x_obs <- rnorm(n,x,x_sd)
y_obs <- rnorm(n,y,y_sd)
# function to show uncertainty shadings
ciPoly <- function(x,en,ep,color=rgb(0,0,0,0.2)) {
polygon( c(x[1], x, x[length(x)], x[length(x)], rev(x), x[1]),
c((ep)[1],ep, (ep)[length(ep)], (en)[length(en)], rev(en), (en)[1]),
border = NA, col = color)}
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l", col = rgb(0,0,0,1))
legend("topleft", legend = c("observations","true relationship", "linear regression"), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), bty = "n", pt.lwd = c(0,NA,NA), col = c(NA,rgb(.5,.5,.5,1),rgb(0,0,0,1)), lty = c(NA,1,2), cex = .65)
errors_in_variables_regression_jags <- function() {
## Likelihood
for (i in 1:n){ #
x_est[i] ~ dnorm(x_obs[i], 1/(x_sd[i]*x_sd[i])) # precision = 1/sigma^2
y_obs[i] ~ dnorm(y_est[i], 1/(y_sd[i]*y_sd[i])) # precision = 1/sigma^2
y_est[i] ~ dnorm(mu[i], tau) # JAGS uses precision `tau` instead of sigma
mu[i] <- alpha + beta * x_est[i]
}
## Priors
tau ~ dgamma(1, 1)  # gamma prior for precision
sigma <- 1/sqrt(tau) # calculate standard deviation
alpha ~ dnorm(0, 1/(100*100))
beta ~ dnorm(0, 1/(100*100))
}
library(R2jags)
regression_data <- list("x_obs", "y_obs", "x_sd", "y_sd","n")
lm_jags  <- jags(data = regression_data,
parameters.to.save = c("alpha",
"beta",
"sigma",
"y_est",
"x_est"
),
n.iter = 3000,
n.thin = 1,
n.chains =  3, # Other values set at default (for simplicity)
model.file = errors_in_variables_regression_jags)
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
legend("topleft", legend = c("observations","true relationship", "lm() regression"
), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), pt.lwd = c(0,NA,NA), col = c(NA,rgb(0.5,0.5,0.5,1),"black"), lty = c(NA,1,2,2), cex = .65)
legend("bottomright", legend = c("JAGS estimates",
"JAGS regression"), pt.bg  = c(rgb(0.9,0.33,0,0.5), NA), pch = c(24,NA), lwd = c(NA,2),  pt.cex = c(1,NA,NA,NA), pt.lwd = c(0,NA), col = c(NA,rgb(0.9,0.33,0,1)), lty = c(NA,2), cex = .65)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
regmat <- matrix(NA,nrow = 1500, ncol = length(x_seq))
for(i in 1:1500) {
regmat[i,] <- lm_jags$BUGSoutput$sims.list$alpha[i] + lm_jags$BUGSoutput$sims.list$beta[i]*x_seq
}
reg_025 <- apply(regmat, 2, function(x) quantile(x, probs = 0.025))
reg_975 <- apply(regmat, 2, function(x) quantile(x, probs = 0.975))
ciPoly(x_seq, reg_975,reg_025, col = rgb(0.9,.33,0,0.25))
points(range(x_obs), lm_jags$BUGSoutput$mean$alpha + range(x_obs)*lm_jags$BUGSoutput$mean$beta, type = "l", col = rgb(0.9,.33,0,1),lwd=2)
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l")
points(lm_jags$BUGSoutput$mean$x_est,lm_jags$BUGSoutput$mean$y_est,pch=24, col = NA, bg = rgb(0.9,0.33,0,0.5))
sapply(1:n,function(a) points(points(c(lm_jags$BUGSoutput$mean$x_est[a],x_obs[a]),c(lm_jags$BUGSoutput$mean$y_est[a],y_obs[a]), type = "l", lty = 3, col = rgb(0.9,0.33,0,0.5))
))
set.seed(1) # change the seed for a different sequence of random numbers
n <- 30 # number of total data points
x <- runif(n,-2,2) # generate the true x
y <- 2 + 0.75 * x # generate the true y
# define the standard deviations of the normal uncertainties with which x and y where observed
x_sd <- runif(n,0.1,0.33)
y_sd <- runif(n,0.1,0.75)
# generate observations from x and y, given these uncertainties
x_obs <- rnorm(n,x,x_sd)
y_obs <- rnorm(n,y,y_sd)
# function to show uncertainty shadings
ciPoly <- function(x,en,ep,color=rgb(0,0,0,0.2)) {
polygon( c(x[1], x, x[length(x)], x[length(x)], rev(x), x[1]),
c((ep)[1],ep, (ep)[length(ep)], (en)[length(en)], rev(en), (en)[1]),
border = NA, col = color)}
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l", col = rgb(0,0,0,1))
legend("topleft", legend = c("observations","true relationship", "linear regression"), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), bty = "n", pt.lwd = c(0,NA,NA), col = c(NA,rgb(.5,.5,.5,1),rgb(0,0,0,1)), lty = c(NA,1,2), cex = .65)
set.seed(1) # change the seed for a different sequence of random numbers
n <- 30 # number of total data points
x <- runif(n,-2,2) # generate the true x
y <- 2 + 0.8 * x # generate the true y
# define the standard deviations of the normal uncertainties with which x and y where observed
x_sd <- runif(n,0.15,0.3)
y_sd <- runif(n,0.1,0.75)
# generate observations from x and y, given these uncertainties
x_obs <- rnorm(n,x,x_sd)
y_obs <- rnorm(n,y,y_sd)
# function to show uncertainty shadings
ciPoly <- function(x,en,ep,color=rgb(0,0,0,0.2)) {
polygon( c(x[1], x, x[length(x)], x[length(x)], rev(x), x[1]),
c((ep)[1],ep, (ep)[length(ep)], (en)[length(en)], rev(en), (en)[1]),
border = NA, col = color)}
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l", col = rgb(0,0,0,1))
legend("topleft", legend = c("observations","true relationship", "linear regression"), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), bty = "n", pt.lwd = c(0,NA,NA), col = c(NA,rgb(.5,.5,.5,1),rgb(0,0,0,1)), lty = c(NA,1,2), cex = .65)
errors_in_variables_regression_jags <- function() {
## Likelihood
for (i in 1:n){ #
x_est[i] ~ dnorm(x_obs[i], 1/(x_sd[i]*x_sd[i])) # precision = 1/sigma^2
y_obs[i] ~ dnorm(y_est[i], 1/(y_sd[i]*y_sd[i])) # precision = 1/sigma^2
y_est[i] ~ dnorm(mu[i], tau) # JAGS uses precision `tau` instead of sigma
mu[i] <- alpha + beta * x_est[i]
}
## Priors
tau ~ dgamma(1, 1)  # gamma prior for precision
sigma <- 1/sqrt(tau) # calculate standard deviation
alpha ~ dnorm(0, 1/(100*100))
beta ~ dnorm(0, 1/(100*100))
}
library(R2jags)
regression_data <- list("x_obs", "y_obs", "x_sd", "y_sd","n")
lm_jags  <- jags(data = regression_data,
parameters.to.save = c("alpha",
"beta",
"sigma",
"y_est",
"x_est"
),
n.iter = 3000,
n.thin = 1,
n.chains =  3, # Other values set at default (for simplicity)
model.file = errors_in_variables_regression_jags)
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
legend("topleft", legend = c("observations","true relationship", "lm() regression"
), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), pt.lwd = c(0,NA,NA), col = c(NA,rgb(0.5,0.5,0.5,1),"black"), lty = c(NA,1,2,2), cex = .65)
legend("bottomright", legend = c("JAGS estimates",
"JAGS regression"), pt.bg  = c(rgb(0.9,0.33,0,0.5), NA), pch = c(24,NA), lwd = c(NA,2),  pt.cex = c(1,NA,NA,NA), pt.lwd = c(0,NA), col = c(NA,rgb(0.9,0.33,0,1)), lty = c(NA,2), cex = .65)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
regmat <- matrix(NA,nrow = 1500, ncol = length(x_seq))
for(i in 1:1500) {
regmat[i,] <- lm_jags$BUGSoutput$sims.list$alpha[i] + lm_jags$BUGSoutput$sims.list$beta[i]*x_seq
}
reg_025 <- apply(regmat, 2, function(x) quantile(x, probs = 0.025))
reg_975 <- apply(regmat, 2, function(x) quantile(x, probs = 0.975))
ciPoly(x_seq, reg_975,reg_025, col = rgb(0.9,.33,0,0.25))
points(range(x_obs), lm_jags$BUGSoutput$mean$alpha + range(x_obs)*lm_jags$BUGSoutput$mean$beta, type = "l", col = rgb(0.9,.33,0,1),lwd=2)
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l")
points(lm_jags$BUGSoutput$mean$x_est,lm_jags$BUGSoutput$mean$y_est,pch=24, col = NA, bg = rgb(0.9,0.33,0,0.5))
sapply(1:n,function(a) points(points(c(lm_jags$BUGSoutput$mean$x_est[a],x_obs[a]),c(lm_jags$BUGSoutput$mean$y_est[a],y_obs[a]), type = "l", lty = 3, col = rgb(0.9,0.33,0,0.5))
))
set.seed(1) # change the seed for a different sequence of random numbers
n <- 30 # number of total data points
x <- runif(n,-2,2) # generate the true x
y <- 2 + 0.6 * x # generate the true y
# define the standard deviations of the normal uncertainties with which x and y where observed
x_sd <- runif(n,0.2,0.3)
y_sd <- runif(n,0.1,0.75)
# generate observations from x and y, given these uncertainties
x_obs <- rnorm(n,x,x_sd)
y_obs <- rnorm(n,y,y_sd)
# function to show uncertainty shadings
ciPoly <- function(x,en,ep,color=rgb(0,0,0,0.2)) {
polygon( c(x[1], x, x[length(x)], x[length(x)], rev(x), x[1]),
c((ep)[1],ep, (ep)[length(ep)], (en)[length(en)], rev(en), (en)[1]),
border = NA, col = color)}
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l", col = rgb(0,0,0,1))
legend("topleft", legend = c("observations","true relationship", "linear regression"), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), bty = "n", pt.lwd = c(0,NA,NA), col = c(NA,rgb(.5,.5,.5,1),rgb(0,0,0,1)), lty = c(NA,1,2), cex = .65)
set.seed(1) # change the seed for a different sequence of random numbers
n <- 30 # number of total data points
x <- runif(n,-2,2) # generate the true x
y <- 2 + 0.75 * x # generate the true y
# define the standard deviations of the normal uncertainties with which x and y where observed
x_sd <- runif(n,0.2,0.4)
y_sd <- runif(n,0.2,1)
# generate observations from x and y, given these uncertainties
x_obs <- rnorm(n,x,x_sd)
y_obs <- rnorm(n,y,y_sd)
# function to show uncertainty shadings
ciPoly <- function(x,en,ep,color=rgb(0,0,0,0.2)) {
polygon( c(x[1], x, x[length(x)], x[length(x)], rev(x), x[1]),
c((ep)[1],ep, (ep)[length(ep)], (en)[length(en)], rev(en), (en)[1]),
border = NA, col = color)}
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l", col = rgb(0,0,0,1))
legend("topleft", legend = c("observations","true relationship", "linear regression"), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), bty = "n", pt.lwd = c(0,NA,NA), col = c(NA,rgb(.5,.5,.5,1),rgb(0,0,0,1)), lty = c(NA,1,2), cex = .65)
set.seed(1) # change the seed for a different sequence of random numbers
n <- 30 # number of total data points
x <- runif(n,-2,2) # generate the true x
y <- 2 + 0.75 * x # generate the true y
# define the standard deviations of the normal uncertainties with which x and y where observed
x_sd <- runif(n,0.2,0.5)
y_sd <- runif(n,0.2,1)
# generate observations from x and y, given these uncertainties
x_obs <- rnorm(n,x,x_sd)
y_obs <- rnorm(n,y,y_sd)
# function to show uncertainty shadings
ciPoly <- function(x,en,ep,color=rgb(0,0,0,0.2)) {
polygon( c(x[1], x, x[length(x)], x[length(x)], rev(x), x[1]),
c((ep)[1],ep, (ep)[length(ep)], (en)[length(en)], rev(en), (en)[1]),
border = NA, col = color)}
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l", col = rgb(0,0,0,1))
legend("topleft", legend = c("observations","true relationship", "linear regression"), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), bty = "n", pt.lwd = c(0,NA,NA), col = c(NA,rgb(.5,.5,.5,1),rgb(0,0,0,1)), lty = c(NA,1,2), cex = .65)
errors_in_variables_regression_jags <- function() {
## Likelihood
for (i in 1:n){ #
x_est[i] ~ dnorm(x_obs[i], 1/(x_sd[i]*x_sd[i])) # precision = 1/sigma^2
y_obs[i] ~ dnorm(y_est[i], 1/(y_sd[i]*y_sd[i])) # precision = 1/sigma^2
y_est[i] ~ dnorm(mu[i], tau) # JAGS uses precision `tau` instead of sigma
mu[i] <- alpha + beta * x_est[i]
}
## Priors
tau ~ dgamma(1, 1)  # gamma prior for precision
sigma <- 1/sqrt(tau) # calculate standard deviation
alpha ~ dnorm(0, 1/(100*100))
beta ~ dnorm(0, 1/(100*100))
}
library(R2jags)
regression_data <- list("x_obs", "y_obs", "x_sd", "y_sd","n")
lm_jags  <- jags(data = regression_data,
parameters.to.save = c("alpha",
"beta",
"sigma",
"y_est",
"x_est"
),
n.iter = 3000,
n.thin = 1,
n.chains =  3, # Other values set at default (for simplicity)
model.file = errors_in_variables_regression_jags)
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
legend("topleft", legend = c("observations","true relationship", "lm() regression"
), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), pt.lwd = c(0,NA,NA), col = c(NA,rgb(0.5,0.5,0.5,1),"black"), lty = c(NA,1,2,2), cex = .65)
legend("bottomright", legend = c("JAGS estimates",
"JAGS regression"), pt.bg  = c(rgb(0.9,0.33,0,0.5), NA), pch = c(24,NA), lwd = c(NA,2),  pt.cex = c(1,NA,NA,NA), pt.lwd = c(0,NA), col = c(NA,rgb(0.9,0.33,0,1)), lty = c(NA,2), cex = .65)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
regmat <- matrix(NA,nrow = 1500, ncol = length(x_seq))
for(i in 1:1500) {
regmat[i,] <- lm_jags$BUGSoutput$sims.list$alpha[i] + lm_jags$BUGSoutput$sims.list$beta[i]*x_seq
}
reg_025 <- apply(regmat, 2, function(x) quantile(x, probs = 0.025))
reg_975 <- apply(regmat, 2, function(x) quantile(x, probs = 0.975))
ciPoly(x_seq, reg_975,reg_025, col = rgb(0.9,.33,0,0.25))
points(range(x_obs), lm_jags$BUGSoutput$mean$alpha + range(x_obs)*lm_jags$BUGSoutput$mean$beta, type = "l", col = rgb(0.9,.33,0,1),lwd=2)
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l")
points(lm_jags$BUGSoutput$mean$x_est,lm_jags$BUGSoutput$mean$y_est,pch=24, col = NA, bg = rgb(0.9,0.33,0,0.5))
sapply(1:n,function(a) points(points(c(lm_jags$BUGSoutput$mean$x_est[a],x_obs[a]),c(lm_jags$BUGSoutput$mean$y_est[a],y_obs[a]), type = "l", lty = 3, col = rgb(0.9,0.33,0,0.5))
))
set.seed(1) # change the seed for a different sequence of random numbers
n <- 30 # number of total data points
x <- runif(n,-2,2) # generate the true x
y <- 2 + 0.75 * x # generate the true y
# define the standard deviations of the normal uncertainties with which x and y where observed
x_sd <- runif(n,0.2,0.6)
y_sd <- runif(n,0.2,1)
# generate observations from x and y, given these uncertainties
x_obs <- rnorm(n,x,x_sd)
y_obs <- rnorm(n,y,y_sd)
# function to show uncertainty shadings
ciPoly <- function(x,en,ep,color=rgb(0,0,0,0.2)) {
polygon( c(x[1], x, x[length(x)], x[length(x)], rev(x), x[1]),
c((ep)[1],ep, (ep)[length(ep)], (en)[length(en)], rev(en), (en)[1]),
border = NA, col = color)}
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l", col = rgb(0,0,0,1))
legend("topleft", legend = c("observations","true relationship", "linear regression"), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), bty = "n", pt.lwd = c(0,NA,NA), col = c(NA,rgb(.5,.5,.5,1),rgb(0,0,0,1)), lty = c(NA,1,2), cex = .65)
errors_in_variables_regression_jags <- function() {
## Likelihood
for (i in 1:n){ #
x_est[i] ~ dnorm(x_obs[i], 1/(x_sd[i]*x_sd[i])) # precision = 1/sigma^2
y_obs[i] ~ dnorm(y_est[i], 1/(y_sd[i]*y_sd[i])) # precision = 1/sigma^2
y_est[i] ~ dnorm(mu[i], tau) # JAGS uses precision `tau` instead of sigma
mu[i] <- alpha + beta * x_est[i]
}
## Priors
tau ~ dgamma(1, 1)  # gamma prior for precision
sigma <- 1/sqrt(tau) # calculate standard deviation
alpha ~ dnorm(0, 1/(100*100))
beta ~ dnorm(0, 1/(100*100))
}
errors_in_variables_regression_jags <- function() {
## Likelihood
for (i in 1:n){ #
x_est[i] ~ dnorm(x_obs[i], 1/(x_sd[i]*x_sd[i])) # precision = 1/sigma^2
y_obs[i] ~ dnorm(y_est[i], 1/(y_sd[i]*y_sd[i])) # precision = 1/sigma^2
y_est[i] ~ dnorm(mu[i], tau) # JAGS uses precision `tau` instead of sigma
mu[i] <- alpha + beta * x_est[i]
}
## Priors
tau ~ dgamma(1, 1)  # gamma prior for precision
sigma <- 1/sqrt(tau) # calculate standard deviation
alpha ~ dnorm(0, 1/(100*100))
beta ~ dnorm(0, 1/(100*100))
}
library(R2jags)
regression_data <- list("x_obs", "y_obs", "x_sd", "y_sd","n")
lm_jags  <- jags(data = regression_data,
parameters.to.save = c("alpha",
"beta",
"sigma",
"y_est",
"x_est"
),
n.iter = 3000,
n.thin = 1,
n.chains =  3, # Other values set at default (for simplicity)
model.file = errors_in_variables_regression_jags)
par(mar = c(4,4,1,1), las = 1, mgp = c(2.25,0.75,0), cex = 1.35)
plot(x_obs,y_obs,pch=21,col=NA,bg=rgb(0,0,0,0.5),
xlab = "x", ylab = "y")
lm_true <- lm(y~x)
points(range(x_obs),lm_true$coefficients[1]+lm_true$coefficients[2]*range(x_obs),type="l",lwd=2,col = rgb(0.5,0.5,0.5,1))
lm1 <- lm(y_obs~x_obs)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
x_pred <- predict.lm(lm1,newdata = data.frame(x_obs=x_seq), interval = "confidence")
ciPoly(x_seq,x_pred[,2],x_pred[,3])
legend("topleft", legend = c("observations","true relationship", "lm() regression"
), pt.bg  = c(rgb(0,0,0,0.5), NA, NA), pch = c(21,NA, NA), lwd = c(NA,2,2),  pt.cex = c(1,NA,NA), pt.lwd = c(0,NA,NA), col = c(NA,rgb(0.5,0.5,0.5,1),"black"), lty = c(NA,1,2,2), cex = .65)
legend("bottomright", legend = c("JAGS estimates",
"JAGS regression"), pt.bg  = c(rgb(0.9,0.33,0,0.5), NA), pch = c(24,NA), lwd = c(NA,2),  pt.cex = c(1,NA,NA,NA), pt.lwd = c(0,NA), col = c(NA,rgb(0.9,0.33,0,1)), lty = c(NA,2), cex = .65)
x_seq <- seq(min(x_obs),max(x_obs),length.out = 100)
regmat <- matrix(NA,nrow = 1500, ncol = length(x_seq))
for(i in 1:1500) {
regmat[i,] <- lm_jags$BUGSoutput$sims.list$alpha[i] + lm_jags$BUGSoutput$sims.list$beta[i]*x_seq
}
reg_025 <- apply(regmat, 2, function(x) quantile(x, probs = 0.025))
reg_975 <- apply(regmat, 2, function(x) quantile(x, probs = 0.975))
ciPoly(x_seq, reg_975,reg_025, col = rgb(0.9,.33,0,0.25))
points(range(x_obs), lm_jags$BUGSoutput$mean$alpha + range(x_obs)*lm_jags$BUGSoutput$mean$beta, type = "l", col = rgb(0.9,.33,0,1),lwd=2)
points(x_seq,x_pred[,1],lwd=2,lty=2,type = "l")
points(lm_jags$BUGSoutput$mean$x_est,lm_jags$BUGSoutput$mean$y_est,pch=24, col = NA, bg = rgb(0.9,0.33,0,0.5))
sapply(1:n,function(a) points(points(c(lm_jags$BUGSoutput$mean$x_est[a],x_obs[a]),c(lm_jags$BUGSoutput$mean$y_est[a],y_obs[a]), type = "l", lty = 3, col = rgb(0.9,0.33,0,0.5))
))
blogdown:::preview_site()
